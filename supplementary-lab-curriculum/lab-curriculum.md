# COSC-502: Computer Organization and Architecture
## Self-Directed Lab Curriculum

> **Disclaimer:** This curriculum was generated by Claude, an AI assistant created by Anthropic. While care has been taken to provide accurate information and useful resources, users should verify all links, technical details, and academic content. This material is intended to supplement—not replace—official course materials and instructor guidance.

---

## Course Overview

This curriculum is designed for independent study in computer organization and architecture with hands-on labs using TinkerCAD, Logisim, and x86 assembly programming. Each module builds progressively from digital logic fundamentals to complex processor design and low-level programming.

---

## Module 1: Digital Logic Fundamentals

### Learning Objectives
- Understand binary number systems and Boolean algebra
- Build and test basic logic gates
- Analyze truth tables and logic expressions

### TinkerCAD Lab 1.1: Introduction to Logic Gates
**Project:** Build and test all basic logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR)

**Tasks:**
1. Create each gate using TinkerCAD's circuit simulator
2. Wire LEDs to visualize outputs
3. Use switches as inputs to test all input combinations
4. Document truth tables for each gate

**Deliverable:** Screenshot collection with annotated truth tables

### Logisim Lab 1.2: Boolean Expression Implementation
**Project:** Implement Boolean expressions as circuits

**Tasks:**
1. Convert expressions to gate-level circuits: `F = A'B + AB'` (XOR), `F = (A + B)(A' + C)`, `F = ABC + A'B'C'`
2. Use Logisim's analysis tool to verify truth tables
3. Simplify circuits using Boolean algebra laws

**Deliverable:** Logisim circuit files (.circ) with documentation

### Paper 1: The History of Boolean Algebra
**Prompt:** Write a 3-4 page paper on George Boole's development of Boolean algebra and its application to digital circuit design by Claude Shannon. Discuss how Shannon's 1937 master's thesis revolutionized electrical engineering.

**Resources:**
- Shannon, C.E. (1938). "A Symbolic Analysis of Relay and Switching Circuits"
- [Stanford Encyclopedia of Philosophy: George Boole](https://plato.stanford.edu/entries/boole/)

### Video Lectures
- [Ben Eater: Logic Gates from Transistors](https://www.youtube.com/watch?v=sTu3LwpF6XI)
- [Crash Course Computer Science #3: Boolean Logic & Logic Gates](https://www.youtube.com/watch?v=gI-qXk7XojA)
- [Neso Academy: Boolean Algebra Playlist](https://www.youtube.com/playlist?list=PLBlnK6fEyqRjMH3mWf6kwqiTbT798eAOm)

### Reading
- Patterson & Hennessy, "Computer Organization and Design" - Appendix B
- [All About Circuits: Boolean Algebra](https://www.allaboutcircuits.com/textbook/digital/chpt-7/introduction-boolean-algebra/)

---

## Module 2: Combinational Logic Circuits

### Learning Objectives
- Design and build multiplexers and demultiplexers
- Construct arithmetic circuits (adders, subtractors)
- Implement decoders and encoders

### TinkerCAD Lab 2.1: Building a 4-bit Adder
**Project:** Construct a ripple-carry adder from basic gates

**Tasks:**
1. Build a half adder circuit
2. Build a full adder circuit
3. Chain four full adders to create a 4-bit adder
4. Test with various 4-bit binary inputs

**Deliverable:** Working circuit with test documentation

### Logisim Lab 2.2: ALU Design (Part 1)
**Project:** Design an 8-bit Arithmetic Logic Unit

**Tasks:**
1. Implement addition and subtraction operations
2. Add AND, OR, XOR logical operations
3. Create operation selector using multiplexers
4. Add zero and overflow flags

**Deliverable:** Logisim ALU circuit with operation documentation

### Logisim Lab 2.3: 7-Segment Display Decoder
**Project:** Build a BCD to 7-segment display decoder

**Tasks:**
1. Create truth table for all segments (a-g)
2. Derive Boolean expressions for each segment
3. Implement in Logisim with a 7-segment display component
4. Test all decimal digits (0-9)

**Deliverable:** Working decoder circuit with K-map simplifications shown

### Paper 2: Karnaugh Maps and Circuit Optimization
**Prompt:** Write a 3-4 page paper explaining Karnaugh maps as a method for Boolean function simplification. Include worked examples showing how K-maps reduce gate count in practical circuits.

### Video Lectures
- [Ben Eater: Building an 8-bit Computer Series](https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU) (Episodes on ALU)
- [Neso Academy: Combinational Circuits](https://www.youtube.com/playlist?list=PLBlnK6fEyqRjMH3mWf6kwqiTbT798eAOm)
- [Computerphile: Inside the ALU](https://www.youtube.com/watch?v=1I5ZMmrOfnA)

### Reading
- [WikiBooks: Digital Circuits/Adders](https://en.wikibooks.org/wiki/Digital_Circuits/Adders)
- [GeeksforGeeks: Multiplexers in Digital Logic](https://www.geeksforgeeks.org/multiplexers-in-digital-logic/)

---

## Module 3: Sequential Logic Circuits

### Learning Objectives
- Understand the difference between combinational and sequential logic
- Build flip-flops and latches
- Design counters and registers

### TinkerCAD Lab 3.1: SR Latch and D Flip-Flop
**Project:** Build memory elements from basic gates

**Tasks:**
1. Construct an SR latch using NOR gates
2. Build a gated SR latch (with enable)
3. Convert to a D flip-flop
4. Test and document state transitions

**Deliverable:** Working circuits with timing diagrams

### Logisim Lab 3.2: 4-bit Register File
**Project:** Design a register file with read/write capabilities

**Tasks:**
1. Build a single 4-bit register using D flip-flops
2. Create a 4-register file (R0-R3)
3. Implement 2-bit address decoding for read/write
4. Add dual read ports (read two registers simultaneously)

**Deliverable:** Register file circuit with usage documentation

### Logisim Lab 3.3: Binary Counter with Display
**Project:** Build a synchronous 4-bit counter

**Tasks:**
1. Design a 4-bit up counter
2. Add down-counting capability
3. Implement load and reset functions
4. Connect to 7-segment display from Module 2

**Deliverable:** Complete counter circuit with control documentation

### Paper 3: Memory Hierarchy in Modern Computers
**Prompt:** Write a 4-5 page paper on memory hierarchy, covering registers, cache (L1, L2, L3), RAM, and storage. Explain why hierarchy exists and discuss concepts like locality of reference, cache hits/misses, and memory bandwidth.

### Video Lectures
- [Ben Eater: SR Latch](https://www.youtube.com/watch?v=KM0DdEaY5sY)
- [Ben Eater: D Flip-Flop](https://www.youtube.com/watch?v=YW-_GkUguMM)
- [Computerphile: Registers and RAM](https://www.youtube.com/watch?v=fpnE6UAfbtU)

### Reading
- Patterson & Hennessy, Chapter 5: Memory Hierarchy
- [All About Circuits: Sequential Circuits](https://www.allaboutcircuits.com/textbook/digital/chpt-10/s-r-latch/)

---

## Module 4: Computer Architecture Fundamentals

### Learning Objectives
- Understand von Neumann architecture
- Learn instruction set architecture concepts
- Explore the fetch-decode-execute cycle

### Logisim Lab 4.1: Simple Instruction Decoder
**Project:** Build an instruction decoder for a simplified ISA

**Tasks:**
1. Define a simple 8-bit instruction format (3-bit opcode, 5-bit operand)
2. Design decoder logic for 8 instructions (ADD, SUB, LOAD, STORE, JUMP, etc.)
3. Generate control signals based on opcode
4. Test with sample instruction sequences

**Deliverable:** Decoder circuit with ISA documentation

### Logisim Lab 4.2: Program Counter and Control Unit
**Project:** Design control logic for sequential execution

**Tasks:**
1. Build a program counter with increment and load
2. Implement branch/jump logic
3. Create a simple state machine for fetch-decode-execute
4. Connect to instruction decoder from Lab 4.1

**Deliverable:** Control unit with state diagram documentation

### Logisim Lab 4.3: Complete Simple CPU
**Project:** Assemble a working (simplified) CPU

**Tasks:**
1. Integrate ALU from Module 2
2. Connect register file from Module 3
3. Add instruction memory (ROM)
4. Wire control unit and data paths
5. Execute a simple program (e.g., add two numbers)

**Deliverable:** Working CPU simulation with test programs

### Paper 4: RISC vs. CISC Architectures
**Prompt:** Write a 4-5 page paper comparing RISC and CISC instruction set architectures. Discuss historical development (focusing on x86 as CISC and ARM as RISC), design trade-offs, and modern hybrid approaches.

### Video Lectures
- [Computerphile: Inside the CPU](https://www.youtube.com/watch?v=IAkj32VPcUE)
- [Crash Course Computer Science #7: The Central Processing Unit](https://www.youtube.com/watch?v=FZGugFqdr60)
- [MIT OpenCourseWare: Computation Structures](https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/)

### Reading
- Patterson & Hennessy, Chapter 4: The Processor
- [Computer History Museum: The Birth of RISC](https://computerhistory.org/blog/risc-versus-cisc/)
- [Ars Technica: Understanding the Microprocessor](https://arstechnica.com/features/2004/02/understanding-the-microprocessor/)

---

## Module 5: Introduction to x86 Assembly

### Learning Objectives
- Set up development environment for x86 assembly
- Understand registers, memory addressing, and basic instructions
- Write simple assembly programs

### Environment Setup
**Required Tools:**
- NASM (Netwide Assembler): https://www.nasm.us/
- GDB (GNU Debugger)
- Linux environment (native, WSL, or VM)

**Alternative Online Tools:**
- [Compiler Explorer (Godbolt)](https://godbolt.org/) - Excellent for seeing C-to-assembly compilation
- [x86 Emulator (copy.sh)](https://copy.sh/v86/)

### Assembly Lab 5.1: Hello World and Basic I/O
**Project:** Write your first x86-64 assembly programs

**Tasks:**
1. Write "Hello, World!" using Linux syscalls
2. Read user input and echo it back
3. Understand the difference between .data, .bss, and .text sections
4. Use GDB to step through execution

**Deliverable:** Commented assembly source files

### Assembly Lab 5.2: Arithmetic Operations
**Project:** Implement a calculator in assembly

**Tasks:**
1. Addition and subtraction of user-provided numbers
2. Multiplication using MUL/IMUL
3. Division using DIV/IDIV (handle remainder)
4. Convert ASCII input to integers and back

**Deliverable:** Working calculator with error handling

### Assembly Lab 5.3: Control Flow
**Project:** Implement branching and loops

**Tasks:**
1. Write an if-else structure in assembly
2. Implement a while loop to sum numbers 1 to N
3. Create a for-loop equivalent using CMP and JMP
4. Build a number guessing game

**Deliverable:** Programs demonstrating each control structure

### Paper 5: The Evolution of x86 Architecture
**Prompt:** Write a 4-5 page paper tracing x86 from the 8086 (1978) through modern processors. Discuss backward compatibility challenges, the transition to 64-bit (x86-64/AMD64), and how Intel and AMD have extended the architecture.

### Video Lectures
- [Davy Wybiral: x86 Assembly Tutorial](https://www.youtube.com/playlist?list=PLmxT2pVYo5LB5EzTPZGfFN0c2GDiSXgQe)
- [OpenSecurityTraining: Introduction to x86](https://opensecuritytraining.info/IntroX86.html)
- [Ben Eater: Assembly Language Basics](https://www.youtube.com/watch?v=wLXIWKUWpSs)

### Reading
- [x86 Assembly Guide (Virginia)](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html)
- [Intel x86 Assembly Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [x86 Instruction Reference](https://www.felixcloutier.com/x86/)

---

## Module 6: x86 Memory and Stack

### Learning Objectives
- Understand memory segmentation and addressing modes
- Master stack operations and calling conventions
- Write functions with proper stack frames

### Assembly Lab 6.1: Memory Addressing Modes
**Project:** Explore x86 addressing modes

**Tasks:**
1. Direct addressing: access fixed memory locations
2. Register indirect: [rax], [rbx + 4]
3. Base + index: [rbx + rsi*4]
4. Implement array traversal using each mode

**Deliverable:** Documented examples of each addressing mode

### Assembly Lab 6.2: Stack Operations
**Project:** Master the stack

**Tasks:**
1. PUSH and POP operations with visualization
2. Implement a stack-based expression evaluator
3. Write recursive factorial function
4. Analyze stack growth using GDB

**Deliverable:** Stack-based programs with memory diagrams

### Assembly Lab 6.3: Functions and Calling Conventions
**Project:** Write proper x86-64 functions

**Tasks:**
1. Implement System V AMD64 ABI calling convention
2. Write a function with local variables (stack frame)
3. Call C library functions from assembly
4. Call your assembly functions from C

**Deliverable:** Mixed C/assembly programs demonstrating interoperability

### Paper 6: Stack-Based Buffer Overflow Vulnerabilities
**Prompt:** Write a 4-5 page paper explaining stack-based buffer overflows. Discuss how they work at the assembly level, historical exploits (Morris Worm, Code Red), and modern mitigations (ASLR, stack canaries, DEP/NX bit).

### Video Lectures
- [LiveOverflow: Binary Exploitation Playlist](https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)
- [Computerphile: The Stack](https://www.youtube.com/watch?v=7ha8qnQ-HU8)

### Reading
- [Smashing the Stack for Fun and Profit](http://phrack.org/issues/49/14.html) (Classic paper by Aleph One)
- [x86-64 ABI Reference](https://gitlab.com/x86-psABIs/x86-64-ABI)

---

## Module 7: Advanced x86 and Optimization

### Learning Objectives
- Understand instruction pipelining and hazards
- Learn SIMD instructions (SSE/AVX)
- Analyze and optimize assembly code

### Assembly Lab 7.1: SIMD Programming
**Project:** Use SSE/AVX for parallel computation

**Tasks:**
1. Add two arrays of floats using SSE
2. Implement dot product using SIMD
3. Compare performance with scalar version
4. Explore memory alignment requirements

**Deliverable:** SIMD-optimized programs with benchmarks

### Assembly Lab 7.2: Inline Assembly in C
**Project:** Mix C and assembly for optimization

**Tasks:**
1. Write inline assembly using GCC extended asm
2. Optimize a critical loop using inline assembly
3. Use compiler intrinsics for SIMD
4. Analyze compiler output with -S flag

**Deliverable:** C programs with inline assembly optimization

### Assembly Lab 7.3: Reverse Engineering Basics
**Project:** Analyze compiled binaries

**Tasks:**
1. Compile C programs and analyze generated assembly
2. Use objdump and readelf to examine binaries
3. Identify functions, loops, and data structures in assembly
4. Modify a binary's behavior (simple crackme)

**Deliverable:** Analysis report with annotated disassembly

### Paper 7: Modern CPU Optimization Techniques
**Prompt:** Write a 5-6 page paper on modern CPU optimization including: instruction pipelining, branch prediction, out-of-order execution, speculative execution, and the security implications (Spectre/Meltdown).

### Video Lectures
- [Computerphile: Spectre and Meltdown](https://www.youtube.com/watch?v=I5mRwzVvFGE)
- [CppCon: Understanding Compiler Optimization](https://www.youtube.com/watch?v=FnGCDLhaxKU)

### Reading
- Patterson & Hennessy, Chapter 4: Advanced Pipelining
- [Intel Optimization Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [Agner Fog's Optimization Manuals](https://www.agner.org/optimize/)

---

## Module 8: Input/Output and Interrupts

### Learning Objectives
- Understand memory-mapped I/O and port-mapped I/O
- Learn interrupt handling mechanisms
- Interface with hardware at the assembly level

### Logisim Lab 8.1: Memory-Mapped I/O
**Project:** Add I/O devices to your CPU from Module 4

**Tasks:**
1. Implement address decoding for I/O region
2. Add a memory-mapped LED display
3. Add memory-mapped switches for input
4. Write programs that use I/O devices

**Deliverable:** CPU with I/O capabilities

### TinkerCAD Lab 8.2: Serial Communication
**Project:** Build a simple UART transmitter

**Tasks:**
1. Understand RS-232 serial protocol
2. Build shift register for serial output
3. Implement start/stop bits
4. Transmit ASCII characters serially

**Deliverable:** Working UART circuit with documentation

### Assembly Lab 8.3: System Calls and OS Interaction
**Project:** Deep dive into Linux system calls

**Tasks:**
1. Implement file I/O using syscalls (open, read, write, close)
2. Create a simple file copy program
3. Use mmap for memory-mapped file access
4. Explore /proc filesystem from assembly

**Deliverable:** Assembly programs demonstrating various syscalls

### Paper 8: The Role of Interrupts in Modern Computing
**Prompt:** Write a 4-5 page paper on interrupt-driven I/O. Explain polling vs. interrupts, interrupt priority, interrupt controllers (APIC), and how modern operating systems handle interrupts.

### Video Lectures
- [Ben Eater: Output Register](https://www.youtube.com/watch?v=aT3qmb_TeKY)
- [Linux System Calls with Assembly](https://www.youtube.com/watch?v=VlJFLK1vr4U)

### Reading
- Patterson & Hennessy, Chapter 6: I/O
- [OSDev Wiki: Interrupts](https://wiki.osdev.org/Interrupts)
- [Linux Kernel Documentation: System Calls](https://www.kernel.org/doc/html/latest/process/adding-syscalls.html)

---

## Module 9: Capstone Project

### Learning Objectives
- Integrate all learned concepts
- Design and implement a complete system
- Document and present technical work

### Option A: Complete 8-bit CPU in Logisim
**Project:** Design a fully functional 8-bit CPU

**Requirements:**
1. At least 8 instructions (arithmetic, logic, memory, control flow)
2. 4+ general-purpose registers
3. Working ALU with flags
4. Program counter and branch support
5. Memory interface (RAM and ROM)
6. Basic I/O capability

**Deliverables:**
- Complete Logisim circuit
- ISA specification document
- Sample programs with expected outputs
- 10-15 page technical report

### Option B: Assembly Language Project
**Project:** Implement a significant program in x86 assembly

**Suggested Projects:**
1. **Text Editor:** Simple line-based text editor with file I/O
2. **Game:** Text-based game (hangman, number guessing, simple maze)
3. **Encryption Tool:** Implement AES or simpler cipher
4. **Image Processor:** Basic operations on BMP files
5. **Compression:** Implement RLE or simple LZ compression

**Deliverables:**
- Fully commented assembly source code
- README with build and usage instructions
- Test cases and expected outputs
- 10-15 page technical report explaining design decisions

### Option C: Hardware/Software Co-Design
**Project:** Design CPU in Logisim with custom assembler

**Requirements:**
1. Design simple CPU in Logisim
2. Define instruction set architecture
3. Write assembler in Python/C to convert assembly to machine code
4. Write sample programs in your assembly language

**Deliverables:**
- Logisim CPU circuit
- Assembler source code
- ISA documentation
- Sample programs
- 15-20 page technical report

---

## Supplementary Resources

### Textbooks
1. **Patterson & Hennessy** - "Computer Organization and Design: The Hardware/Software Interface" (Primary text)
2. **Hennessy & Patterson** - "Computer Architecture: A Quantitative Approach" (Advanced)
3. **Bryant & O'Hallaron** - "Computer Systems: A Programmer's Perspective" (Systems focus)
4. **Kip Irvine** - "Assembly Language for x86 Processors" (Assembly focus)

### Online Courses
1. [MIT 6.004: Computation Structures](https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/)
2. [Berkeley CS61C: Great Ideas in Computer Architecture](https://cs61c.org/)
3. [Coursera: Nand2Tetris](https://www.coursera.org/learn/build-a-computer) (Build a computer from scratch)
4. [CMU 15-213: Introduction to Computer Systems](https://www.cs.cmu.edu/~213/)

### Interactive Simulators
1. **Logisim Evolution**: https://github.com/logisim-evolution/logisim-evolution
2. **TinkerCAD Circuits**: https://www.tinkercad.com/circuits
3. **Digital Logic Simulator**: https://simulator.io/
4. **MARS MIPS Simulator**: https://courses.missouristate.edu/KenVollmar/MARS/
5. **Visual x86 Emulator**: https://carlosrafaelgn.com.br/asm86/

### Reference Sites
1. [x86 Instruction Reference](https://www.felixcloutier.com/x86/)
2. [OSDev Wiki](https://wiki.osdev.org/) - OS development resource
3. [Godbolt Compiler Explorer](https://godbolt.org/) - See C compile to assembly
4. [CPU World](https://www.cpu-world.com/) - CPU specifications database

### YouTube Channels
1. **Ben Eater** - Excellent hardware tutorials
2. **Computerphile** - Computer science concepts
3. **LiveOverflow** - Security and binary exploitation
4. **Sebastian Lague** - Visual algorithm explanations
5. **Neso Academy** - Digital logic and computer organization

---

## Assessment Rubric

### Labs (50%)
| Criteria | Excellent (A) | Good (B) | Satisfactory (C) | Needs Work (D/F) |
|----------|---------------|----------|------------------|------------------|
| Functionality | Works completely, handles edge cases | Works for typical inputs | Partially works | Does not function |
| Documentation | Clear, comprehensive comments | Adequate documentation | Minimal comments | No documentation |
| Design | Elegant, efficient solution | Good structure | Works but inefficient | Poor organization |

### Papers (30%)
| Criteria | Excellent (A) | Good (B) | Satisfactory (C) | Needs Work (D/F) |
|----------|---------------|----------|------------------|------------------|
| Content | Deep understanding, original insights | Solid understanding | Basic understanding | Misconceptions |
| Research | Multiple quality sources, well-integrated | Good sources | Minimal sources | No credible sources |
| Writing | Clear, professional, well-organized | Minor issues | Readable but rough | Unclear, disorganized |

### Capstone (20%)
| Criteria | Excellent (A) | Good (B) | Satisfactory (C) | Needs Work (D/F) |
|----------|---------------|----------|------------------|------------------|
| Scope | Ambitious, exceeds requirements | Meets requirements | Partially complete | Minimal effort |
| Technical | Sophisticated implementation | Solid implementation | Basic implementation | Doesn't work |
| Report | Publication quality | Professional | Acceptable | Incomplete |

---

## Suggested Weekly Schedule (16 weeks)

| Week | Module | Focus |
|------|--------|-------|
| 1-2 | Module 1 | Digital Logic Fundamentals |
| 3-4 | Module 2 | Combinational Logic |
| 5-6 | Module 3 | Sequential Logic |
| 7-8 | Module 4 | Computer Architecture |
| 9-10 | Module 5 | x86 Assembly Basics |
| 11-12 | Module 6 | Memory and Stack |
| 13-14 | Module 7 | Advanced x86 |
| 15 | Module 8 | I/O and Interrupts |
| 16 | Module 9 | Capstone Presentations |

---

*Last updated: February 2026*
